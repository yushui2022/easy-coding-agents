# AI Coding Agent Integration Guide

> **Target Audience**: AI Assistants (Claude, GPT-4, Gemini) & Human Developers.
> **Purpose**: Rapidly understand the architecture, data flow, and extension points of `easy-coding-agent` to perform code modifications safely and effectively.

## 1. Architecture Overview (The Big Picture)

This project is a high-performance, asynchronous AI coding agent designed with a **Control Loop** philosophy, mimicking Claude Code's architecture.

### Core Components Map

*   **Engine (n0/h2A)**: `core/engine.py`
    *   **Role**: The brain and scheduler.
    *   **Mechanism**: Double-Buffered Async Queue (`input_queue` -> `processing_queue`).
    *   **Key Loop**: `_run_autonomous_loop` - Task-driven state machine.
*   **Stream (wu)**: `core/stream.py`
    *   **Role**: LLM I/O handler.
    *   **Mechanism**: ThreadPoolExecutor + Async Generator for non-blocking streaming.
*   **Memory (3-Tier)**: `memory/` package
    *   **Short-Term**: `memory/short_term.py` (Buffer + Token Monitor).
    *   **Medium-Term**: `memory/medium_term.py` (AU2 Compressor via LLM).
    *   **Long-Term**: `memory/long_term.py` (Atomic file persistence in `CLAUDE.md`).
    *   **Session Store**: `memory/session_store.py` (JSON Serialization for Resume).
    *   **Manager**: `memory/__init__.py` (Facade pattern).
*   **Task System (Control Loop)**: `core/task.py`
    *   **Role**: The "conscience" that keeps the agent on track.
    *   **Mechanism**: State machine (Pending -> In Progress -> Completed).
    *   **Visualization**: Terminal Progress Bar (`print_progress`).
*   **UI/UX Layer**: `utils/logger.py` & `core/engine.py`
    *   **Role**: Human-Computer Interaction.
    *   **Tech**: `rich` library (Panels, JSON Syntax Highlighting, Progress Bars).
    *   **Localization**: All output is localized to Chinese (CN).
*   **Tools**: `tools/` package
    *   **Registry**: `tools/base.py` (Decorator-based registration).
    *   **Impls**: `filesystem.py`, `shell.py`, `search.py`, `todo.py`.
    *   **Internal**: `manage_core_memory` (Proactive memory management).

## 2. Critical Data Flows

### A. The Autonomous Execution Loop
1.  **Input**: User types command -> `input_queue` -> `processing_queue`.
2.  **State Injection**: `Engine` checks `TaskManager`.
    *   *Idle* -> Prompt: "Plan tasks first".
    *   *Working* -> Prompt: "Execute Task X".
3.  **Context Assembly**: `MemoryManager.get_context()`
    *   Checks Token Limit -> (Optional) Triggers AU2 Compression.
    *   Injects System Prompt + Long Term Memory + Active Context + System State.
4.  **LLM Call**: `StreamHandler` streams response.
5.  **Tool Execution**: Result captured (Rich formatted) -> Added to Memory -> Loop continues.

### B. Memory Lifecycle
*   **Write**: `memory.add()` -> `ShortTermMemory` (Raises `MemoryOverflowError` if full).
*   **Auto-Save**: Triggered on `Engine` loop or `Compression` -> `SessionStore.save()` (Writes `memory/sessions/session_*.json`).
*   **Read**: `memory.get_context()` -> Catches Overflow -> Calls `MediumTermMemory.compress()` -> Updates ShortTerm.
*   **Resume**: `Engine.start()` -> `MemoryManager.initialize()` -> Loads latest JSON session if exists.
*   **Value Extraction**: During AU2 compression, if `decisions` are found, they are auto-promoted to `CLAUDE.md`.
*   **Persist**: `memory.long_term.update()` -> Atomic write to `CLAUDE.md`.

## 3. Developer / AI Operator Cheatsheet

### How to Add a New Tool
1.  Create `tools/new_tool.py`.
2.  Import registry: `from tools.base import registry`.
3.  Decorate function: `@registry.register(name="...", description="...")`.
4.  **CRITICAL**: Register in `core/engine.py` imports (`import tools.new_tool`).

### How to Modify System Prompt
*   Edit `core/prompts.py`.
*   **Note**: The prompt is dynamic. Engine injects `System State` (Task status) and `Long Term Memory` at runtime.

### How to Debug
*   **Logs**: `utils/logger.py` handles output.
    *   **Suppression**: `httpx` and `httpcore` logs are set to WARNING level to reduce noise.
    *   **Windows ANSI**: VT100 injection is handled here.
*   **Async**: The entire core is `asyncio`. Use `await` properly.
*   **Queues**: `Engine` uses `join()` to sync with CLI. If CLI hangs, check queue task completion.

## 4. Key Constraints & Invariants

1.  **Task-Driven**: The Agent MUST NOT execute complex logic without a Todo entry.
2.  **No Blocking**: Never use `time.sleep()` or blocking IO in the main loop. Use `asyncio.sleep()` or `aiofiles`.
3.  **Token Safety**: Respect `MAX_HISTORY_TOKENS`. The memory system handles compression, but tools should not return megabytes of text.
4.  **Windows First**: This project is optimized for Windows (PowerShell/CMD). Path separators and encoding (UTF-8) are handled strictly.
5.  **Workspace Discipline**: All new files generated by the Agent (unless part of the core system) MUST be written to the `workspace/` directory to keep the root clean.
6.  **Proactive Memory**: Use `manage_core_memory` to save reusable Knowledge/Rules/Experience to `CLAUDE.md`.

## 5. Quick Context Loading (For AI Agents)
*   **Read Config**: `.env` & `core/config.py`
*   **Read Memory**: `memory/__init__.py`
*   **Read Engine**: `core/engine.py`
